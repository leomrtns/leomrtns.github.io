<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>biomcmc-lib: topology_common.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="_biomcmclib-thumbnail.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">biomcmc-lib
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">low level library for phylogenetic analysis</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">topology_common.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>General-purpose topology structures created from nexus_tree_struct (and low-level functions)  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="bipartition_8h_source.html">bipartition.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="distance__matrix_8h_source.html">distance_matrix.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="empirical__frequency_8h_source.html">empirical_frequency.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for topology_common.h:</div>
<div class="dyncontent">
<div class="center"><img src="topology__common_8h__incl.png" border="0" usemap="#topology__common_8h" alt=""/></div>
<map name="topology__common_8h" id="topology__common_8h">
<area shape="rect" id="node2" href="bipartition_8h.html" title="Unary/binary operators on arbitrarily&#45;sized bitstrings (strings of zeros and ones) like split biparti..." alt="" coords="512,603,601,629"/>
<area shape="rect" id="node20" href="distance__matrix_8h.html" title="distance matrix, that can be used in alignments and trees, and patristic&#45;distance based species dista..." alt="" coords="462,155,587,181"/>
<area shape="rect" id="node23" href="empirical__frequency_8h.html" title="Creates a histogram of a vector, ordered by frequency. " alt="" coords="574,80,723,107"/>
<area shape="rect" id="node3" href="lowlevel_8h.html" title="Lowest level header file. Header file for lowlevel.c. " alt="" coords="669,677,749,704"/>
<area shape="rect" id="node21" href="hashtable_8h.html" title="double hashing open&#45;address hash table using strings as key – also has distance matrix, that can be used in alignments and trees " alt="" coords="512,453,601,480"/>
<area shape="rect" id="node22" href="hashfunctions_8h.html" title="Collections of hash functions for 32 and 64 bits, including one&#45;liners, murmurhash, and xxhash. " alt="" coords="499,528,614,555"/>
<area shape="rect" id="node24" href="char__vector_8h.html" title="list of strings (each string is a vector of chars) " alt="" coords="611,155,713,181"/>
<area shape="rect" id="node25" href="prob__distribution_8h.html" title="Probability distribution functions and auxiliary mathematical functions from statistical package R..." alt="" coords="594,229,722,256"/>
<area shape="rect" id="node26" href="random__number_8h.html" title="Random number generation, with algorithms from the Gnu Scientific Library (GSL) and motivation from t..." alt="" coords="537,304,664,331"/>
<area shape="rect" id="node27" href="random__number__gen_8h_source.html" title="random_number_gen.h" alt="" coords="517,379,671,405"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="topology__common_8h__dep__incl.png" border="0" usemap="#topology__common_8hdep" alt=""/></div>
<map name="topology__common_8hdep" id="topology__common_8hdep">
<area shape="rect" id="node2" href="topology__distance_8h.html" title="branch length operations on topologies, including patristic distances " alt="" coords="92,80,231,107"/>
<area shape="rect" id="node3" href="parsimony_8h.html" title="binary and multistate parsimony matrices, together with bipartition extraction for MRP ..." alt="" coords="5,229,99,256"/>
<area shape="rect" id="node5" href="topology__randomise_8h.html" title="Creation of random topologies and modification of existing ones through branch swapping. " alt="" coords="257,155,407,181"/>
<area shape="rect" id="node10" href="read__newick__trees_8h.html" title="Low&#45;level functions for reading newick strings. " alt="" coords="90,155,233,181"/>
<area shape="rect" id="node4" href="biomcmc_8h.html" title="biomcmc library interface to external programs, specific to super_sptree repo. " alt="" coords="138,379,225,405"/>
<area shape="rect" id="node6" href="upgma_8h.html" title="UPGMA and bioNJ from (onedimensional representation of) distance matrices. " alt="" coords="289,229,361,256"/>
<area shape="rect" id="node7" href="genetree_8h.html" title="gene tree and species tree structures, for reconciliation etc. This is the high&#45;level file with globa..." alt="" coords="273,304,356,331"/>
<area shape="rect" id="node8" href="reconciliation_8h.html" title="low&#45;level file for gene tree and species tree reconciliation. This file is hidden from user and conta..." alt="" coords="260,379,369,405"/>
<area shape="rect" id="node9" href="splitset__distances_8h.html" title="Low&#45;level functions that use only the split bipartitions of topologies – treating them as unrooted u..." alt="" coords="245,453,384,480"/>
<area shape="rect" id="node11" href="newick__space_8h.html" title="Reads a list of trees in newick format and creates vector of topologies. " alt="" coords="123,229,239,256"/>
<area shape="rect" id="node12" href="topology__space_8h.html" title="Reads tree files in nexus format and creates a vector of topologies. " alt="" coords="119,304,243,331"/>
</map>
</div>
</div>
<p><a href="topology__common_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtopol__node__struct.html">topol_node_struct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Information of a node (binary tree).  <a href="structtopol__node__struct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structtopology__struct.html">topology_struct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary unrooted topology (rooted at leaf with ID zero)  <a href="structtopology__struct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a996cc8f62d29656325d956b30b1d7cdf"><td class="memItemLeft" align="right" valign="top"><a id="a996cc8f62d29656325d956b30b1d7cdf"></a>
typedef struct <a class="el" href="structtopol__node__struct.html">topol_node_struct</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>topol_node</b></td></tr>
<tr class="separator:a996cc8f62d29656325d956b30b1d7cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84f4179678a44fe3dd321d10fc4d58a0"><td class="memItemLeft" align="right" valign="top"><a id="a84f4179678a44fe3dd321d10fc4d58a0"></a>
typedef struct <a class="el" href="structtopology__struct.html">topology_struct</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>topology</b></td></tr>
<tr class="separator:a84f4179678a44fe3dd321d10fc4d58a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac8291febbe6145a25c3f21931ddc4f12"><td class="memItemLeft" align="right" valign="top"><a id="ac8291febbe6145a25c3f21931ddc4f12"></a>
<a class="el" href="structtopology__struct.html">topology</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology__common_8h.html#ac8291febbe6145a25c3f21931ddc4f12">new_topology</a> (int nleaves)</td></tr>
<tr class="memdesc:ac8291febbe6145a25c3f21931ddc4f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate space for new <a class="el" href="structtopology__struct.html" title="Binary unrooted topology (rooted at leaf with ID zero) ">topology_struct</a>. <br /></td></tr>
<tr class="separator:ac8291febbe6145a25c3f21931ddc4f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afef9dfca253f6e961e349f289b10c7d8"><td class="memItemLeft" align="right" valign="top"><a id="afef9dfca253f6e961e349f289b10c7d8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology__common_8h.html#afef9dfca253f6e961e349f289b10c7d8">topology_malloc_blength</a> (<a class="el" href="structtopology__struct.html">topology</a> tree)</td></tr>
<tr class="memdesc:afef9dfca253f6e961e349f289b10c7d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocate vector for branch lengths (3 vectors: mean, min and max values observed in topol_space collection) <br /></td></tr>
<tr class="separator:afef9dfca253f6e961e349f289b10c7d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43cdaa9b821e3e8059be8097576921d5"><td class="memItemLeft" align="right" valign="top"><a id="a43cdaa9b821e3e8059be8097576921d5"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology__common_8h.html#a43cdaa9b821e3e8059be8097576921d5">del_topology</a> (<a class="el" href="structtopology__struct.html">topology</a> topol)</td></tr>
<tr class="memdesc:a43cdaa9b821e3e8059be8097576921d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Free space allocated by <a class="el" href="structtopology__struct.html" title="Binary unrooted topology (rooted at leaf with ID zero) ">topology_struct</a>. <br /></td></tr>
<tr class="separator:a43cdaa9b821e3e8059be8097576921d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1044e831883af50f68ed2819ca81272b"><td class="memItemLeft" align="right" valign="top"><a id="a1044e831883af50f68ed2819ca81272b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>debug_topol</b> (<a class="el" href="structtopology__struct.html">topology</a> tree)</td></tr>
<tr class="separator:a1044e831883af50f68ed2819ca81272b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d1514270e2f2575eaa94f454b425d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology__common_8h.html#a83d1514270e2f2575eaa94f454b425d5">copy_topology_from_topology</a> (<a class="el" href="structtopology__struct.html">topology</a> to_tree, <a class="el" href="structtopology__struct.html">topology</a> from_tree)</td></tr>
<tr class="memdesc:a83d1514270e2f2575eaa94f454b425d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy information from <a class="el" href="structtopology__struct.html" title="Binary unrooted topology (rooted at leaf with ID zero) ">topology_struct</a>.  <a href="#a83d1514270e2f2575eaa94f454b425d5">More...</a><br /></td></tr>
<tr class="separator:a83d1514270e2f2575eaa94f454b425d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ae251ff6844438a1891ee3ab10ad70"><td class="memItemLeft" align="right" valign="top"><a id="ad1ae251ff6844438a1891ee3ab10ad70"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology__common_8h.html#ad1ae251ff6844438a1891ee3ab10ad70">update_topology_sisters</a> (<a class="el" href="structtopology__struct.html">topology</a> tree)</td></tr>
<tr class="memdesc:ad1ae251ff6844438a1891ee3ab10ad70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update pointers to topol_node_struct::sister. <br /></td></tr>
<tr class="separator:ad1ae251ff6844438a1891ee3ab10ad70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff833f0afb5478b2da6c2e3591750e3"><td class="memItemLeft" align="right" valign="top"><a id="a2ff833f0afb5478b2da6c2e3591750e3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology__common_8h.html#a2ff833f0afb5478b2da6c2e3591750e3">update_topology_traversal</a> (<a class="el" href="structtopology__struct.html">topology</a> tree)</td></tr>
<tr class="memdesc:a2ff833f0afb5478b2da6c2e3591750e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update topol_node::preorder, topol_node::postorder, topol_node::bipartition and order siblings by number of descendants. <br /></td></tr>
<tr class="separator:a2ff833f0afb5478b2da6c2e3591750e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6835412616c6e3aee7a752664ab2d452"><td class="memItemLeft" align="right" valign="top"><a id="a6835412616c6e3aee7a752664ab2d452"></a>
<a class="el" href="lowlevel_8h.html#a97a80ca1602ebf2303258971a2c938e2">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology__common_8h.html#a6835412616c6e3aee7a752664ab2d452">topology_is_equal</a> (<a class="el" href="structtopology__struct.html">topology</a> t1, <a class="el" href="structtopology__struct.html">topology</a> t2)</td></tr>
<tr class="memdesc:a6835412616c6e3aee7a752664ab2d452"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two topologies based on bipartitions as clades (not on branch lengths) <br /></td></tr>
<tr class="separator:a6835412616c6e3aee7a752664ab2d452"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf57ef1d396f3f84fcaedda2529009fb"><td class="memItemLeft" align="right" valign="top"><a id="abf57ef1d396f3f84fcaedda2529009fb"></a>
<a class="el" href="lowlevel_8h.html#a97a80ca1602ebf2303258971a2c938e2">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology__common_8h.html#abf57ef1d396f3f84fcaedda2529009fb">topology_is_equal_unrooted</a> (<a class="el" href="structtopology__struct.html">topology</a> t1, <a class="el" href="structtopology__struct.html">topology</a> t2, <a class="el" href="lowlevel_8h.html#a97a80ca1602ebf2303258971a2c938e2">bool</a> use_root_later)</td></tr>
<tr class="memdesc:abf57ef1d396f3f84fcaedda2529009fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare two topologies based on bipartitions neglecting root; boolean ask if split should be reverted to original orientation. <br /></td></tr>
<tr class="separator:abf57ef1d396f3f84fcaedda2529009fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11e8e50c89c3e943661968aed34fb0b"><td class="memItemLeft" align="right" valign="top"><a id="af11e8e50c89c3e943661968aed34fb0b"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology__common_8h.html#af11e8e50c89c3e943661968aed34fb0b">reorder_topology_leaves</a> (<a class="el" href="structtopology__struct.html">topology</a> tree)</td></tr>
<tr class="memdesc:af11e8e50c89c3e943661968aed34fb0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reorder <a class="el" href="structchar__vector__struct.html" title="vector of strings (char vectors) of variable length ">char_vector_struct</a>; leaf node ids (and bipartitions) must then follow this order. <br /></td></tr>
<tr class="separator:af11e8e50c89c3e943661968aed34fb0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1a22b2dec13f46ba3b68e83477cd12"><td class="memItemLeft" align="right" valign="top"><a id="a9a1a22b2dec13f46ba3b68e83477cd12"></a>
<a class="el" href="lowlevel_8h.html#a97a80ca1602ebf2303258971a2c938e2">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology__common_8h.html#a9a1a22b2dec13f46ba3b68e83477cd12">node1_is_child_of_node2</a> (<a class="el" href="structtopol__node__struct.html">topol_node</a> node1, <a class="el" href="structtopol__node__struct.html">topol_node</a> node2)</td></tr>
<tr class="memdesc:a9a1a22b2dec13f46ba3b68e83477cd12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Boolean if node2 is on the path of node1 to the root. <br /></td></tr>
<tr class="separator:a9a1a22b2dec13f46ba3b68e83477cd12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6db1cb85d5a57b3a3c91fe735861204a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology__common_8h.html#a6db1cb85d5a57b3a3c91fe735861204a">topology_to_string_by_id</a> (const <a class="el" href="structtopology__struct.html">topology</a> tree, double *blen)</td></tr>
<tr class="memdesc:a6db1cb85d5a57b3a3c91fe735861204a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print subtree in newick format to string using leaf IDs.  <a href="#a6db1cb85d5a57b3a3c91fe735861204a">More...</a><br /></td></tr>
<tr class="separator:a6db1cb85d5a57b3a3c91fe735861204a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa60cb33af89c2c7b74bb218eb9468bf3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology__common_8h.html#aa60cb33af89c2c7b74bb218eb9468bf3">topology_to_string_create_name</a> (const <a class="el" href="structtopology__struct.html">topology</a> tree, double *blen)</td></tr>
<tr class="memdesc:aa60cb33af89c2c7b74bb218eb9468bf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print subtree in newick format to string creating names (based on leaf IDs.)  <a href="#aa60cb33af89c2c7b74bb218eb9468bf3">More...</a><br /></td></tr>
<tr class="separator:aa60cb33af89c2c7b74bb218eb9468bf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa728f9d79edb4799b279bd837398b75d"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology__common_8h.html#aa728f9d79edb4799b279bd837398b75d">topology_to_string_by_name</a> (const <a class="el" href="structtopology__struct.html">topology</a> tree, double *blen)</td></tr>
<tr class="memdesc:aa728f9d79edb4799b279bd837398b75d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print subtree in newick format to string using leaf names.  <a href="#aa728f9d79edb4799b279bd837398b75d">More...</a><br /></td></tr>
<tr class="separator:aa728f9d79edb4799b279bd837398b75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee3da24d5b00f28be299e8231dc7789"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology__common_8h.html#afee3da24d5b00f28be299e8231dc7789">graphviz_file_topology</a> (FILE *fout, char *label, const <a class="el" href="structtopology__struct.html">topology</a> tree)</td></tr>
<tr class="memdesc:afee3da24d5b00f28be299e8231dc7789"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints subtree in dot format to file.  <a href="#afee3da24d5b00f28be299e8231dc7789">More...</a><br /></td></tr>
<tr class="separator:afee3da24d5b00f28be299e8231dc7789"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b9b2dacd758c4a9a79075fd582e824"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology__common_8h.html#ac0b9b2dacd758c4a9a79075fd582e824">apply_spr_at_nodes</a> (<a class="el" href="structtopology__struct.html">topology</a> p, <a class="el" href="structtopol__node__struct.html">topol_node</a> prune, <a class="el" href="structtopol__node__struct.html">topol_node</a> regraft, <a class="el" href="lowlevel_8h.html#a97a80ca1602ebf2303258971a2c938e2">bool</a> update_done)</td></tr>
<tr class="memdesc:ac0b9b2dacd758c4a9a79075fd582e824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply one subtree prune-and-regraft (SPR branch swapping) operation at specified nodes.  <a href="#ac0b9b2dacd758c4a9a79075fd582e824">More...</a><br /></td></tr>
<tr class="separator:ac0b9b2dacd758c4a9a79075fd582e824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62e09c235d771e69aee2993e79e9731c"><td class="memItemLeft" align="right" valign="top"><a id="a62e09c235d771e69aee2993e79e9731c"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology__common_8h.html#a62e09c235d771e69aee2993e79e9731c">apply_spr_at_nodes_LCAprune</a> (<a class="el" href="structtopology__struct.html">topology</a> tree, <a class="el" href="structtopol__node__struct.html">topol_node</a> prune, <a class="el" href="structtopol__node__struct.html">topol_node</a> regraft, <a class="el" href="lowlevel_8h.html#a97a80ca1602ebf2303258971a2c938e2">bool</a> update_done)</td></tr>
<tr class="memdesc:a62e09c235d771e69aee2993e79e9731c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply one SPR branch swapping at specified nodes when prune subtree is above prune node. <br /></td></tr>
<tr class="separator:a62e09c235d771e69aee2993e79e9731c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3d4404bbf462e60510a35810d617d3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology__common_8h.html#aa3d4404bbf462e60510a35810d617d3f">apply_spr_at_nodes_notLCAprune</a> (<a class="el" href="structtopology__struct.html">topology</a> tree, <a class="el" href="structtopol__node__struct.html">topol_node</a> prune, <a class="el" href="structtopol__node__struct.html">topol_node</a> regraft, <a class="el" href="lowlevel_8h.html#a97a80ca1602ebf2303258971a2c938e2">bool</a> update_done)</td></tr>
<tr class="memdesc:aa3d4404bbf462e60510a35810d617d3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply one SPR branch swapping at specified nodes when subtree to be pruned is below prune node.  <a href="#aa3d4404bbf462e60510a35810d617d3f">More...</a><br /></td></tr>
<tr class="separator:aa3d4404bbf462e60510a35810d617d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95c8cdd4571f36a098d29b2a1d54f3d"><td class="memItemLeft" align="right" valign="top"><a id="ae95c8cdd4571f36a098d29b2a1d54f3d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology__common_8h.html#ae95c8cdd4571f36a098d29b2a1d54f3d">topology_undo_random_move</a> (<a class="el" href="structtopology__struct.html">topology</a> tree, <a class="el" href="lowlevel_8h.html#a97a80ca1602ebf2303258971a2c938e2">bool</a> update_done)</td></tr>
<tr class="memdesc:ae95c8cdd4571f36a098d29b2a1d54f3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">revert last SPR branch swapping <br /></td></tr>
<tr class="separator:ae95c8cdd4571f36a098d29b2a1d54f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd897c1f66dc20e16d13606f3c7d2684"><td class="memItemLeft" align="right" valign="top"><a id="acd897c1f66dc20e16d13606f3c7d2684"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology__common_8h.html#acd897c1f66dc20e16d13606f3c7d2684">clear_topology_flags</a> (<a class="el" href="structtopology__struct.html">topology</a> tree)</td></tr>
<tr class="memdesc:acd897c1f66dc20e16d13606f3c7d2684"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset all d_done and u_done booleans to "true" (when rejecting a new state in MCMC) <br /></td></tr>
<tr class="separator:acd897c1f66dc20e16d13606f3c7d2684"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02592320bb8d6c0d6c587e3fe67a290e"><td class="memItemLeft" align="right" valign="top"><a id="a02592320bb8d6c0d6c587e3fe67a290e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology__common_8h.html#a02592320bb8d6c0d6c587e3fe67a290e">raise_topology_flags</a> (<a class="el" href="structtopology__struct.html">topology</a> tree)</td></tr>
<tr class="memdesc:a02592320bb8d6c0d6c587e3fe67a290e"><td class="mdescLeft">&#160;</td><td class="mdescRight">reset all d_done and u_done booleans to "false" (when updating a model parameter with MTM) <br /></td></tr>
<tr class="separator:a02592320bb8d6c0d6c587e3fe67a290e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae10e4d2ac03cd340e2bdbc955deeb98d"><td class="memItemLeft" align="right" valign="top"><a id="ae10e4d2ac03cd340e2bdbc955deeb98d"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology__common_8h.html#ae10e4d2ac03cd340e2bdbc955deeb98d">topology_reset_random_move</a> (<a class="el" href="structtopology__struct.html">topology</a> tree)</td></tr>
<tr class="memdesc:ae10e4d2ac03cd340e2bdbc955deeb98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">revert last SPR branch swapping and clear flags (reject last proposal, in MCMC) <br /></td></tr>
<tr class="separator:ae10e4d2ac03cd340e2bdbc955deeb98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc404c846a472241f1d8bee9ff69196"><td class="memItemLeft" align="right" valign="top"><a id="a1dc404c846a472241f1d8bee9ff69196"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology__common_8h.html#a1dc404c846a472241f1d8bee9ff69196">copy_topology_to_intvector_by_postorder</a> (<a class="el" href="structtopology__struct.html">topology</a> tree, int *ivec)</td></tr>
<tr class="memdesc:a1dc404c846a472241f1d8bee9ff69196"><td class="mdescLeft">&#160;</td><td class="mdescRight">store ID of each node's parent (in postorder) into vector, returning number of stored nodes <br /></td></tr>
<tr class="separator:a1dc404c846a472241f1d8bee9ff69196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877c063091488c9440864b537074b2a2"><td class="memItemLeft" align="right" valign="top"><a id="a877c063091488c9440864b537074b2a2"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology__common_8h.html#a877c063091488c9440864b537074b2a2">copy_intvector_to_topology_by_postorder</a> (<a class="el" href="structtopology__struct.html">topology</a> tree, int *ivec)</td></tr>
<tr class="memdesc:a877c063091488c9440864b537074b2a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">restore topological structure based on postordered ID vector, returning number of restored nodes <br /></td></tr>
<tr class="separator:a877c063091488c9440864b537074b2a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b2182e8fe4a91acdbe04f4a3b6a9ef"><td class="memItemLeft" align="right" valign="top"><a id="a35b2182e8fe4a91acdbe04f4a3b6a9ef"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology__common_8h.html#a35b2182e8fe4a91acdbe04f4a3b6a9ef">copy_topology_to_intvector_by_id</a> (<a class="el" href="structtopology__struct.html">topology</a> tree, int *ivec)</td></tr>
<tr class="memdesc:a35b2182e8fe4a91acdbe04f4a3b6a9ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">store ID of each node's parent into vector <br /></td></tr>
<tr class="separator:a35b2182e8fe4a91acdbe04f4a3b6a9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e10f61f4c12949770e11fd17cee1144"><td class="memItemLeft" align="right" valign="top"><a id="a2e10f61f4c12949770e11fd17cee1144"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="topology__common_8h.html#a2e10f61f4c12949770e11fd17cee1144">copy_intvector_to_topology_by_id</a> (<a class="el" href="structtopology__struct.html">topology</a> tree, int *ivec)</td></tr>
<tr class="memdesc:a2e10f61f4c12949770e11fd17cee1144"><td class="mdescLeft">&#160;</td><td class="mdescRight">restore topological structure based on ID vector <br /></td></tr>
<tr class="separator:a2e10f61f4c12949770e11fd17cee1144"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>General-purpose topology structures created from nexus_tree_struct (and low-level functions) </p>
<p>The topology structure should actually be called "tree" since it has information about branch lengths, but these functions neglect branch lenght information. Here we have functions that create split bipartitions for edges (stored by nodes below the edge) and compare distinct topologies based on these bipartitions. We also have here the lowest-level function that apply an SPR on a topology (again, without caring about the branch length). </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a83d1514270e2f2575eaa94f454b425d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d1514270e2f2575eaa94f454b425d5">&#9670;&nbsp;</a></span>copy_topology_from_topology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void copy_topology_from_topology </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtopology__struct.html">topology</a>&#160;</td>
          <td class="paramname"><em>to_tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtopology__struct.html">topology</a>&#160;</td>
          <td class="paramname"><em>from_tree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy information from <a class="el" href="structtopology__struct.html" title="Binary unrooted topology (rooted at leaf with ID zero) ">topology_struct</a>. </p>
<p>Since IDs do not change, this function only needs to update topol_node_struct::up, topol_node_struct::right, and topol_node_struct::left pointers and topol_node_struct::map_id from internal nodes; update of topol_node::sister is handled by function <a class="el" href="topology__common_8h.html#ad1ae251ff6844438a1891ee3ab10ad70" title="Update pointers to topol_node_struct::sister. ">update_topology_sisters()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">from_tree</td><td>original <a class="el" href="structtopology__struct.html" title="Binary unrooted topology (rooted at leaf with ID zero) ">topology_struct</a> </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">to_tree</td><td>(previously allocated) copied <a class="el" href="structtopology__struct.html" title="Binary unrooted topology (rooted at leaf with ID zero) ">topology_struct</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6db1cb85d5a57b3a3c91fe735861204a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6db1cb85d5a57b3a3c91fe735861204a">&#9670;&nbsp;</a></span>topology_to_string_by_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* topology_to_string_by_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtopology__struct.html">topology</a>&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>blen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print subtree in newick format to string using leaf IDs. </p>
<p>Stores in string the tree in newick format, using leaf ID numbers (in practical applications needs a TRANSLATION nexus block). Memory allocation is handled by this function, but needs to be freed by the calling function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>tree to be printed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blen</td><td>vector with branch lengths (usually tree-&gt;blength) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to newly allocated string </dd></dl>

</div>
</div>
<a id="aa60cb33af89c2c7b74bb218eb9468bf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa60cb33af89c2c7b74bb218eb9468bf3">&#9670;&nbsp;</a></span>topology_to_string_create_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* topology_to_string_create_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtopology__struct.html">topology</a>&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>blen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print subtree in newick format to string creating names (based on leaf IDs.) </p>
<p>Stores in string the tree in newick format, using newly-created names based on leaf ID numbers (useful for generating random trees that must be read by other programs.) Memory allocation is handled by this function, but needs to be freed by the calling function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>tree to be printed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blen</td><td>vector with branch lengths (usually tree-&gt;blength) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to newly allocated string </dd></dl>

</div>
</div>
<a id="aa728f9d79edb4799b279bd837398b75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa728f9d79edb4799b279bd837398b75d">&#9670;&nbsp;</a></span>topology_to_string_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* topology_to_string_by_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structtopology__struct.html">topology</a>&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>blen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print subtree in newick format to string using leaf names. </p>
<p>Stores in string the tree in newick format, preserving sequence names if available. Memory allocation is handled by this function, but needs to be freed by the calling function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td>tree to be printed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">blen</td><td>vector with branch lengths (usually tree-&gt;blength) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a pointer to newly allocated string </dd></dl>

</div>
</div>
<a id="afee3da24d5b00f28be299e8231dc7789"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee3da24d5b00f28be299e8231dc7789">&#9670;&nbsp;</a></span>graphviz_file_topology()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void graphviz_file_topology </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>label</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structtopology__struct.html">topology</a>&#160;</td>
          <td class="paramname"><em>tree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints subtree in dot format to file. </p>
<p>Prints to file the tree in dot format (undirected graph). The dot format can be used with the <a href="http://www.graphviz.org/">graphviz</a> suite of programs, and is not restricted to trees but can also handle arbitrary graph structures. Notice that we do not make use of the graphviz library, we simply create the text file graphviz programs take as input. Unfortunately, it is not helpful to print the nexus_tree_struct since the program works basically with the <a class="el" href="structtopology__struct.html" title="Binary unrooted topology (rooted at leaf with ID zero) ">topology_struct</a>. On the other hand it is easy to change this function to make it work with <a class="el" href="structtopology__struct.html" title="Binary unrooted topology (rooted at leaf with ID zero) ">topology_struct</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">fout</td><td>pointer to file handler where tree is to be printed; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">label</td><td>graph name or any other label; </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tree</td><td><a class="el" href="structtopology__struct.html" title="Binary unrooted topology (rooted at leaf with ID zero) ">topology_struct</a> to be printed; </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0b9b2dacd758c4a9a79075fd582e824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b9b2dacd758c4a9a79075fd582e824">&#9670;&nbsp;</a></span>apply_spr_at_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apply_spr_at_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtopology__struct.html">topology</a>&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtopol__node__struct.html">topol_node</a>&#160;</td>
          <td class="paramname"><em>prune</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtopol__node__struct.html">topol_node</a>&#160;</td>
          <td class="paramname"><em>regraft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lowlevel_8h.html#a97a80ca1602ebf2303258971a2c938e2">bool</a>&#160;</td>
          <td class="paramname"><em>update_done</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply one subtree prune-and-regraft (SPR branch swapping) operation at specified nodes. </p>
<p>Each node is associated to one edge (the branch immediately above it), thus the location of the regraft node will impose the direction of pruning - the prune edge will always detach away from subtree containing regraft. The actual SPR move needs to handle two cases: <b>prune node is in the path from regraft node to the root</b> (prune node is least common ancestor between prune and regraft) and <b>prune node is not in the path from regraft node to root</b> (prune and regraft nodes share a distinct common ancestor). When prune node is the root, the first case implies in rerooting. Checking against illegal moves (prune==regraft, prune==regraft-&gt;up, etc) should be done previous to this function call. This function will call the corresponding lower-level one based on position of prune node. If you know the direction of pruning (rerooting, e.g.) you can call the other two functions directly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">p</td><td>topology over which to apply move </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">prune</td><td>node to be pruned (detached). Direction determined by regraft </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regraft</td><td>node above which prune node will be reattached </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa3d4404bbf462e60510a35810d617d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3d4404bbf462e60510a35810d617d3f">&#9670;&nbsp;</a></span>apply_spr_at_nodes_notLCAprune()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void apply_spr_at_nodes_notLCAprune </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structtopology__struct.html">topology</a>&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtopol__node__struct.html">topol_node</a>&#160;</td>
          <td class="paramname"><em>prune</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structtopol__node__struct.html">topol_node</a>&#160;</td>
          <td class="paramname"><em>regraft</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="lowlevel_8h.html#a97a80ca1602ebf2303258971a2c938e2">bool</a>&#160;</td>
          <td class="paramname"><em>update_done</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply one SPR branch swapping at specified nodes when subtree to be pruned is below prune node. </p>
<p><b>prune is not lca</b>: Detach the prune subtree and reinsert it just above the regraft node (regraft node may be root).</p>
<pre class="fragment">*  Prune: 
*
*  p.left\              /p.up.up                       p.left\                |p.up.up                  
*         \prune___p.up/                       ==&gt;            \p_______prune  |                         
*         /            \                                      /               |                         
* p.right/              \p.up.left || p.up.right      p.right/                |p.up.left || p.up.right  
*
* </pre><pre class="fragment">*  Regraft: 
*
*  p.left\                |r.up        p.left\               /prune.up (=r.up.up)
*         \p_______prune  |      ==&gt;          \p_______prune/ 
*         /               |                   /             \
* p.right/                |r          p.right/               \r
*
* </pre>
</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
