<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>biomcmc-lib: bipartition.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="_biomcmclib-thumbnail.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">biomcmc-lib
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">low level library for phylogenetic analysis</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_97aefd0d527b934f1d99a682da8fe6a9.html">lib</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">bipartition.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Unary/binary operators on arbitrarily-sized bitstrings (strings of zeros and ones) like split bipartitions.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="lowlevel_8h_source.html">lowlevel.h</a>&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for bipartition.h:</div>
<div class="dyncontent">
<div class="center"><img src="bipartition_8h__incl.png" border="0" usemap="#bipartition_8h" alt=""/></div>
<map name="bipartition_8h" id="bipartition_8h">
<area shape="rect" id="node2" href="lowlevel_8h.html" title="Lowest level header file. Header file for lowlevel.c. " alt="" coords="669,80,749,107"/>
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="bipartition_8h__dep__incl.png" border="0" usemap="#bipartition_8hdep" alt=""/></div>
<map name="bipartition_8hdep" id="bipartition_8hdep">
<area shape="rect" id="node2" href="hashfunctions_8h.html" title="Collections of hash functions for 32 and 64 bits, including one&#45;liners, murmurhash, and xxhash. " alt="" coords="125,80,240,107"/>
<area shape="rect" id="node8" href="topology__common_8h.html" title="General&#45;purpose topology structures created from nexus_tree_struct (and low&#45;level functions) ..." alt="" coords="267,603,405,629"/>
<area shape="rect" id="node3" href="hashtable_8h.html" title="double hashing open&#45;address hash table using strings as key – also has distance matrix, that can be used in alignments and trees " alt="" coords="138,155,227,181"/>
<area shape="rect" id="node30" href="hll_8h.html" title="HyperLogLog functions, based on code by Ivan Vitjuk https://github.com/ivitjuk/libhll under an ISC Li..." alt="" coords="251,155,298,181"/>
<area shape="rect" id="node4" href="distance__matrix_8h.html" title="distance matrix, that can be used in alignments and trees, and patristic&#45;distance based species dista..." alt="" coords="529,528,655,555"/>
<area shape="rect" id="node21" href="random__number__gen_8h_source.html" title="random_number_gen.h" alt="" coords="105,229,260,256"/>
<area shape="rect" id="node5" href="alignment_8h.html" title="File handling functions and calculation of distances for sequence data in nexus format. " alt="" coords="477,677,566,704"/>
<area shape="rect" id="node19" href="distance__generator_8h.html" title="distance calculation between generic objects,without generating full matrix beforehand ..." alt="" coords="590,677,733,704"/>
<area shape="rect" id="node6" href="kmerhash_8h.html" title="k&#45;mer handling of DNA sequences, with hash transformation " alt="" coords="520,827,611,853"/>
<area shape="rect" id="node7" href="biomcmc_8h.html" title="biomcmc library interface to external programs, specific to super_sptree repo. " alt="" coords="419,976,506,1003"/>
<area shape="rect" id="node9" href="topology__distance_8h.html" title="branch length operations on topologies, including patristic distances " alt="" coords="261,677,400,704"/>
<area shape="rect" id="node10" href="parsimony_8h.html" title="binary and multistate parsimony matrices, together with bipartition extraction for MRP ..." alt="" coords="283,901,376,928"/>
<area shape="rect" id="node11" href="topology__randomise_8h.html" title="Creation of random topologies and modification of existing ones through branch swapping. " alt="" coords="143,752,292,779"/>
<area shape="rect" id="node16" href="read__newick__trees_8h.html" title="Low&#45;level functions for reading newick strings. " alt="" coords="367,752,510,779"/>
<area shape="rect" id="node12" href="upgma_8h.html" title="UPGMA and bioNJ from (onedimensional representation of) distance matrices. " alt="" coords="181,827,253,853"/>
<area shape="rect" id="node13" href="genetree_8h.html" title="gene tree and species tree structures, for reconciliation etc. This is the high&#45;level file with globa..." alt="" coords="176,901,259,928"/>
<area shape="rect" id="node14" href="reconciliation_8h.html" title="low&#45;level file for gene tree and species tree reconciliation. This file is hidden from user and conta..." alt="" coords="163,976,272,1003"/>
<area shape="rect" id="node15" href="splitset__distances_8h.html" title="Low&#45;level functions that use only the split bipartitions of topologies – treating them as unrooted u..." alt="" coords="148,1051,287,1077"/>
<area shape="rect" id="node17" href="newick__space_8h.html" title="Reads a list of trees in newick format and creates vector of topologies. " alt="" coords="379,827,495,853"/>
<area shape="rect" id="node18" href="topology__space_8h.html" title="Reads tree files in nexus format and creates a vector of topologies. " alt="" coords="401,901,525,928"/>
<area shape="rect" id="node20" href="clustering__goptics_8h.html" title="OPTICS algorithm based on https://github.com/guineri/GOPTICS. " alt="" coords="591,752,729,779"/>
<area shape="rect" id="node22" href="random__number_8h.html" title="Random number generation, with algorithms from the Gnu Scientific Library (GSL) and motivation from t..." alt="" coords="119,304,246,331"/>
<area shape="rect" id="node23" href="prob__distribution_8h.html" title="Probability distribution functions and auxiliary mathematical functions from statistical package R..." alt="" coords="119,379,247,405"/>
<area shape="rect" id="node24" href="char__vector_8h.html" title="list of strings (each string is a vector of chars) " alt="" coords="305,453,407,480"/>
<area shape="rect" id="node29" href="prob__distribution__aux_8h.html" title="Auxiliary (low level) functions for prob_distribution.c. " alt="" coords="105,453,261,480"/>
<area shape="rect" id="node25" href="nexus__common_8h.html" title="File handling functions for nexus format in general. " alt="" coords="429,603,555,629"/>
<area shape="rect" id="node26" href="empirical__frequency_8h.html" title="Creates a histogram of a vector, ordered by frequency. " alt="" coords="180,528,329,555"/>
<area shape="rect" id="node28" href="char__vector_8c.html" title="vector of strings (species names, leaf names, etc.) " alt="" coords="404,528,505,555"/>
<area shape="rect" id="node27" href="empirical__frequency_8c.html" title="histogram of vectors, ordered by frequency. Also calculates MAP (modal) values. " alt="" coords="93,603,243,629"/>
</map>
</div>
</div>
<p><a href="bipartition_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbipartition__struct.html">bipartition_struct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bit-string representation of splits.  <a href="structbipartition__struct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbipsize__struct.html">bipsize_struct</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a306abb015733891f436e9325a3e61716"><td class="memItemLeft" align="right" valign="top"><a id="a306abb015733891f436e9325a3e61716"></a>
typedef struct <a class="el" href="structbipartition__struct.html">bipartition_struct</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>bipartition</b></td></tr>
<tr class="separator:a306abb015733891f436e9325a3e61716"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfcdcb0fabd8a28ab1f40157117ebb6"><td class="memItemLeft" align="right" valign="top"><a id="accfcdcb0fabd8a28ab1f40157117ebb6"></a>
typedef struct <a class="el" href="structbipsize__struct.html">bipsize_struct</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>bipsize</b></td></tr>
<tr class="separator:accfcdcb0fabd8a28ab1f40157117ebb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84eec7a8b7ee401120ae2970eb3c1260"><td class="memItemLeft" align="right" valign="top"><a id="a84eec7a8b7ee401120ae2970eb3c1260"></a>
typedef <a class="el" href="structbipartition__struct.html">bipartition</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>tripartition</b></td></tr>
<tr class="separator:a84eec7a8b7ee401120ae2970eb3c1260"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a4046e91c94efca27e42476132b89edec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structbipartition__struct.html">bipartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#a4046e91c94efca27e42476132b89edec">new_bipartition</a> (int size)</td></tr>
<tr class="memdesc:a4046e91c94efca27e42476132b89edec"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a new bipartition (bitstring) capable of storing an arbitrary number of bits and initialize it to zero  <a href="#a4046e91c94efca27e42476132b89edec">More...</a><br /></td></tr>
<tr class="separator:a4046e91c94efca27e42476132b89edec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4524aef381ee0e194588bf5317439a"><td class="memItemLeft" align="right" valign="top"><a id="a2a4524aef381ee0e194588bf5317439a"></a>
<a class="el" href="structbipsize__struct.html">bipsize</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#a2a4524aef381ee0e194588bf5317439a">new_bipsize</a> (int size)</td></tr>
<tr class="memdesc:a2a4524aef381ee0e194588bf5317439a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new bipsize, which controls some bipartition sizes. <br /></td></tr>
<tr class="separator:a2a4524aef381ee0e194588bf5317439a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79971b17309d8b6dbbd64be3917f1221"><td class="memItemLeft" align="right" valign="top"><a id="a79971b17309d8b6dbbd64be3917f1221"></a>
<a class="el" href="structbipartition__struct.html">bipartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#a79971b17309d8b6dbbd64be3917f1221">new_bipartition_copy_from</a> (const <a class="el" href="structbipartition__struct.html">bipartition</a> from)</td></tr>
<tr class="memdesc:a79971b17309d8b6dbbd64be3917f1221"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new bipartition (allocate memory) and initialize it from another bipartition. <br /></td></tr>
<tr class="separator:a79971b17309d8b6dbbd64be3917f1221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0ba9762329edaf1307a4cb072d58a8c"><td class="memItemLeft" align="right" valign="top"><a id="ac0ba9762329edaf1307a4cb072d58a8c"></a>
<a class="el" href="structbipartition__struct.html">bipartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#ac0ba9762329edaf1307a4cb072d58a8c">new_bipartition_from_bipsize</a> (<a class="el" href="structbipsize__struct.html">bipsize</a> n)</td></tr>
<tr class="memdesc:ac0ba9762329edaf1307a4cb072d58a8c"><td class="mdescLeft">&#160;</td><td class="mdescRight">create new bipartition that will share bipsize &ndash; useful for bipartition vectors <br /></td></tr>
<tr class="separator:ac0ba9762329edaf1307a4cb072d58a8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a269368b8696695e9a0ab30a6807f7215"><td class="memItemLeft" align="right" valign="top"><a id="a269368b8696695e9a0ab30a6807f7215"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#a269368b8696695e9a0ab30a6807f7215">del_bipartition</a> (<a class="el" href="structbipartition__struct.html">bipartition</a> bip)</td></tr>
<tr class="memdesc:a269368b8696695e9a0ab30a6807f7215"><td class="mdescLeft">&#160;</td><td class="mdescRight">free memory allocated by bipartition <br /></td></tr>
<tr class="separator:a269368b8696695e9a0ab30a6807f7215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a359a51341143b01a6596e07eb38599f8"><td class="memItemLeft" align="right" valign="top"><a id="a359a51341143b01a6596e07eb38599f8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#a359a51341143b01a6596e07eb38599f8">del_bipsize</a> (<a class="el" href="structbipsize__struct.html">bipsize</a> n)</td></tr>
<tr class="memdesc:a359a51341143b01a6596e07eb38599f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">free memory allocated by bipsize <br /></td></tr>
<tr class="separator:a359a51341143b01a6596e07eb38599f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9986d7d9721e342f51ccb973d8b05b8"><td class="memItemLeft" align="right" valign="top"><a id="ad9986d7d9721e342f51ccb973d8b05b8"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#ad9986d7d9721e342f51ccb973d8b05b8">bipsize_resize</a> (<a class="el" href="structbipsize__struct.html">bipsize</a> n, int nbits)</td></tr>
<tr class="memdesc:ad9986d7d9721e342f51ccb973d8b05b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">update the valid number of bits and mask &ndash; e.g. when replacing subtrees by leaves in reduced trees <br /></td></tr>
<tr class="separator:ad9986d7d9721e342f51ccb973d8b05b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b35d621e3de681fc8adcc59376c15a"><td class="memItemLeft" align="right" valign="top"><a id="ac1b35d621e3de681fc8adcc59376c15a"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#ac1b35d621e3de681fc8adcc59376c15a">bipartition_initialize</a> (<a class="el" href="structbipartition__struct.html">bipartition</a> bip, int position)</td></tr>
<tr class="memdesc:ac1b35d621e3de681fc8adcc59376c15a"><td class="mdescLeft">&#160;</td><td class="mdescRight">set all bits to zero except the one at position-th bit <br /></td></tr>
<tr class="separator:ac1b35d621e3de681fc8adcc59376c15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de2a0287f3dc861078d5a5cb0691727"><td class="memItemLeft" align="right" valign="top"><a id="a8de2a0287f3dc861078d5a5cb0691727"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#a8de2a0287f3dc861078d5a5cb0691727">bipartition_zero</a> (<a class="el" href="structbipartition__struct.html">bipartition</a> bip)</td></tr>
<tr class="memdesc:a8de2a0287f3dc861078d5a5cb0691727"><td class="mdescLeft">&#160;</td><td class="mdescRight">set all bits to zero <br /></td></tr>
<tr class="separator:a8de2a0287f3dc861078d5a5cb0691727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733578f349b0cb8baea14357929467ba"><td class="memItemLeft" align="right" valign="top"><a id="a733578f349b0cb8baea14357929467ba"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#a733578f349b0cb8baea14357929467ba">bipartition_set</a> (<a class="el" href="structbipartition__struct.html">bipartition</a> bip, int position)</td></tr>
<tr class="memdesc:a733578f349b0cb8baea14357929467ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">simply set the bit at "position" to one, irrespective of other bits <br /></td></tr>
<tr class="separator:a733578f349b0cb8baea14357929467ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a867384f907c2a4a937e1f4972a7d4528"><td class="memItemLeft" align="right" valign="top"><a id="a867384f907c2a4a937e1f4972a7d4528"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bipartition_set_lowlevel</b> (<a class="el" href="structbipartition__struct.html">bipartition</a> bip, int i, int j)</td></tr>
<tr class="separator:a867384f907c2a4a937e1f4972a7d4528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6b3e6c15bddd9e824e4f6fabb4a367"><td class="memItemLeft" align="right" valign="top"><a id="a5a6b3e6c15bddd9e824e4f6fabb4a367"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#a5a6b3e6c15bddd9e824e4f6fabb4a367">bipartition_unset</a> (<a class="el" href="structbipartition__struct.html">bipartition</a> bip, int position)</td></tr>
<tr class="memdesc:a5a6b3e6c15bddd9e824e4f6fabb4a367"><td class="mdescLeft">&#160;</td><td class="mdescRight">simply unset the bit at "position" (set to zero), irrespective of other bits <br /></td></tr>
<tr class="separator:a5a6b3e6c15bddd9e824e4f6fabb4a367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5dc5e89c9d653be234b0afa18efe892"><td class="memItemLeft" align="right" valign="top"><a id="ab5dc5e89c9d653be234b0afa18efe892"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>bipartition_unset_lowlevel</b> (<a class="el" href="structbipartition__struct.html">bipartition</a> bip, int i, int j)</td></tr>
<tr class="separator:ab5dc5e89c9d653be234b0afa18efe892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af43ee65be3d32162462e3db46bfa6c68"><td class="memItemLeft" align="right" valign="top"><a id="af43ee65be3d32162462e3db46bfa6c68"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#af43ee65be3d32162462e3db46bfa6c68">bipartition_copy</a> (<a class="el" href="structbipartition__struct.html">bipartition</a> to, const <a class="el" href="structbipartition__struct.html">bipartition</a> from)</td></tr>
<tr class="memdesc:af43ee65be3d32162462e3db46bfa6c68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy contents from one bipartition to another. <br /></td></tr>
<tr class="separator:af43ee65be3d32162462e3db46bfa6c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08e2a6c72e1b56b0ba7a9305c9571827"><td class="memItemLeft" align="right" valign="top"><a id="a08e2a6c72e1b56b0ba7a9305c9571827"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#a08e2a6c72e1b56b0ba7a9305c9571827">bipartition_OR</a> (<a class="el" href="structbipartition__struct.html">bipartition</a> result, const <a class="el" href="structbipartition__struct.html">bipartition</a> b1, const <a class="el" href="structbipartition__struct.html">bipartition</a> b2, <a class="el" href="lowlevel_8h.html#a97a80ca1602ebf2303258971a2c938e2">bool</a> update_count)</td></tr>
<tr class="memdesc:a08e2a6c72e1b56b0ba7a9305c9571827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary logical OR ("|") between b1 and b2, where update_count should be true if you need to know the resulting size (slow) or false if you don't care or if b1 and b2 are disjoint (no common elements) <br /></td></tr>
<tr class="separator:a08e2a6c72e1b56b0ba7a9305c9571827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8c1099e5da96c71cd4862654a405042"><td class="memItemLeft" align="right" valign="top"><a id="ac8c1099e5da96c71cd4862654a405042"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#ac8c1099e5da96c71cd4862654a405042">bipartition_AND</a> (<a class="el" href="structbipartition__struct.html">bipartition</a> result, const <a class="el" href="structbipartition__struct.html">bipartition</a> b1, const <a class="el" href="structbipartition__struct.html">bipartition</a> b2, <a class="el" href="lowlevel_8h.html#a97a80ca1602ebf2303258971a2c938e2">bool</a> update_count)</td></tr>
<tr class="memdesc:ac8c1099e5da96c71cd4862654a405042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary logical AND ("&amp;") between b1 and b2, update_count should be set to false only if you <b>really</b> don't need to know the number of active bits (e.g. sorting, bipartition comparison) <br /></td></tr>
<tr class="separator:ac8c1099e5da96c71cd4862654a405042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d8733818515fcce7867e3a5dd95def"><td class="memItemLeft" align="right" valign="top"><a id="a42d8733818515fcce7867e3a5dd95def"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#a42d8733818515fcce7867e3a5dd95def">bipartition_ANDNOT</a> (<a class="el" href="structbipartition__struct.html">bipartition</a> result, const <a class="el" href="structbipartition__struct.html">bipartition</a> b1, const <a class="el" href="structbipartition__struct.html">bipartition</a> b2, <a class="el" href="lowlevel_8h.html#a97a80ca1602ebf2303258971a2c938e2">bool</a> update_count)</td></tr>
<tr class="memdesc:a42d8733818515fcce7867e3a5dd95def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary logical AND ("&amp;") between b1 and ~b2 (NOT b2), that is, apply mask b1 on the inverse of b2. <br /></td></tr>
<tr class="separator:a42d8733818515fcce7867e3a5dd95def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78342af45538fc650831e5b65248fb5e"><td class="memItemLeft" align="right" valign="top"><a id="a78342af45538fc650831e5b65248fb5e"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#a78342af45538fc650831e5b65248fb5e">bipartition_XOR</a> (<a class="el" href="structbipartition__struct.html">bipartition</a> result, const <a class="el" href="structbipartition__struct.html">bipartition</a> b1, const <a class="el" href="structbipartition__struct.html">bipartition</a> b2, <a class="el" href="lowlevel_8h.html#a97a80ca1602ebf2303258971a2c938e2">bool</a> update_count)</td></tr>
<tr class="memdesc:a78342af45538fc650831e5b65248fb5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary logical eXclusive OR ("^") between b1 and b2, update_count should be set to false only if you <b>really</b> don't need to know the number of active bits (e.g. sorting, bipartition comparison) <br /></td></tr>
<tr class="separator:a78342af45538fc650831e5b65248fb5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc77e0616198ac07ac5d8fe43193f661"><td class="memItemLeft" align="right" valign="top"><a id="abc77e0616198ac07ac5d8fe43193f661"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#abc77e0616198ac07ac5d8fe43193f661">bipartition_XORNOT</a> (<a class="el" href="structbipartition__struct.html">bipartition</a> result, const <a class="el" href="structbipartition__struct.html">bipartition</a> b1, const <a class="el" href="structbipartition__struct.html">bipartition</a> b2, <a class="el" href="lowlevel_8h.html#a97a80ca1602ebf2303258971a2c938e2">bool</a> update_count)</td></tr>
<tr class="memdesc:abc77e0616198ac07ac5d8fe43193f661"><td class="mdescLeft">&#160;</td><td class="mdescRight">Binary logical eXclusive OR ("^") between b1 and complement of b2 (that is, NOT b2: b1 ^ ~b2). Used when finding best disagreement (that in this case erases the complement &ndash;other side &ndash; of agreement edge) <br /></td></tr>
<tr class="separator:abc77e0616198ac07ac5d8fe43193f661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d1bb39a33b970546ac58ffcb046d8d6"><td class="memItemLeft" align="right" valign="top"><a id="a2d1bb39a33b970546ac58ffcb046d8d6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#a2d1bb39a33b970546ac58ffcb046d8d6">bipartition_NOT</a> (<a class="el" href="structbipartition__struct.html">bipartition</a> result, const <a class="el" href="structbipartition__struct.html">bipartition</a> bip)</td></tr>
<tr class="memdesc:a2d1bb39a33b970546ac58ffcb046d8d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unary complement ("~") of bipartition. Use with caution, since there is no mask for unused padded bits. <br /></td></tr>
<tr class="separator:a2d1bb39a33b970546ac58ffcb046d8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6cdc9daacc3e05c557f87f26cb2c157"><td class="memItemLeft" align="right" valign="top"><a id="af6cdc9daacc3e05c557f87f26cb2c157"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#af6cdc9daacc3e05c557f87f26cb2c157">bipartition_count_n_ones</a> (const <a class="el" href="structbipartition__struct.html">bipartition</a> bip)</td></tr>
<tr class="memdesc:af6cdc9daacc3e05c557f87f26cb2c157"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of active bits (equal to one). Used by <a class="el" href="bipartition_8h.html#ac8c1099e5da96c71cd4862654a405042" title="Binary logical AND (&quot;&amp;&quot;) between b1 and b2, update_count should be set to false only if you really don&#39;t ...">bipartition_AND()</a> and <a class="el" href="bipartition_8h.html#a78342af45538fc650831e5b65248fb5e" title="Binary logical eXclusive OR (&quot;^&quot;) between b1 and b2, update_count should be set to false only if you ...">bipartition_XOR()</a> when update_count = true. Please use it parsimoniously since it is as slow as without bitstring representation. <br /></td></tr>
<tr class="separator:af6cdc9daacc3e05c557f87f26cb2c157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cad78ac8b8dcd7daa5372a2f3e6c696"><td class="memItemLeft" align="right" valign="top"><a id="a2cad78ac8b8dcd7daa5372a2f3e6c696"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#a2cad78ac8b8dcd7daa5372a2f3e6c696">bipartition_to_int_vector</a> (const <a class="el" href="structbipartition__struct.html">bipartition</a> b, int *id, int vecsize)</td></tr>
<tr class="memdesc:a2cad78ac8b8dcd7daa5372a2f3e6c696"><td class="mdescLeft">&#160;</td><td class="mdescRight">fill vector id[] with positions of set bits, up to vecsize bits set <br /></td></tr>
<tr class="separator:a2cad78ac8b8dcd7daa5372a2f3e6c696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47b6d2c862a9b02cada5eef6f3a96933"><td class="memItemLeft" align="right" valign="top"><a id="a47b6d2c862a9b02cada5eef6f3a96933"></a>
<a class="el" href="lowlevel_8h.html#a97a80ca1602ebf2303258971a2c938e2">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#a47b6d2c862a9b02cada5eef6f3a96933">bipartition_is_equal</a> (const <a class="el" href="structbipartition__struct.html">bipartition</a> b1, const <a class="el" href="structbipartition__struct.html">bipartition</a> b2)</td></tr>
<tr class="memdesc:a47b6d2c862a9b02cada5eef6f3a96933"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare equality of two bipartitions. <br /></td></tr>
<tr class="separator:a47b6d2c862a9b02cada5eef6f3a96933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeacfd040b535889cf72d43d74284b0d"><td class="memItemLeft" align="right" valign="top"><a id="afeacfd040b535889cf72d43d74284b0d"></a>
<a class="el" href="lowlevel_8h.html#a97a80ca1602ebf2303258971a2c938e2">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#afeacfd040b535889cf72d43d74284b0d">bipartition_is_equal_bothsides</a> (const <a class="el" href="structbipartition__struct.html">bipartition</a> b1, const <a class="el" href="structbipartition__struct.html">bipartition</a> b2)</td></tr>
<tr class="memdesc:afeacfd040b535889cf72d43d74284b0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare if two bipartitions represent the same splits (or they are equal or one is the complement of the other) <br /></td></tr>
<tr class="separator:afeacfd040b535889cf72d43d74284b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d26658d417eca17423e332d7adddb8a"><td class="memItemLeft" align="right" valign="top"><a id="a2d26658d417eca17423e332d7adddb8a"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#a2d26658d417eca17423e332d7adddb8a">compare_bipartitions_increasing</a> (const void *a1, const void *a2)</td></tr>
<tr class="memdesc:a2d26658d417eca17423e332d7adddb8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bipartitions comparison, to be used by sort() since returns integer and uses (void) <br /></td></tr>
<tr class="separator:a2d26658d417eca17423e332d7adddb8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f310aa1b02d8ca7ad39bac31d446fd"><td class="memItemLeft" align="right" valign="top"><a id="a04f310aa1b02d8ca7ad39bac31d446fd"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#a04f310aa1b02d8ca7ad39bac31d446fd">compare_bipartitions_decreasing</a> (const void *a1, const void *a2)</td></tr>
<tr class="memdesc:a04f310aa1b02d8ca7ad39bac31d446fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bipartitions comparison, to be used by sort() since returns integer and uses (void) <br /></td></tr>
<tr class="separator:a04f310aa1b02d8ca7ad39bac31d446fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d7dac5bc657afaa96de811cfe9c6a92"><td class="memItemLeft" align="right" valign="top"><a id="a5d7dac5bc657afaa96de811cfe9c6a92"></a>
<a class="el" href="lowlevel_8h.html#a97a80ca1602ebf2303258971a2c938e2">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#a5d7dac5bc657afaa96de811cfe9c6a92">bipartition_is_larger</a> (const <a class="el" href="structbipartition__struct.html">bipartition</a> b1, const <a class="el" href="structbipartition__struct.html">bipartition</a> b2)</td></tr>
<tr class="memdesc:a5d7dac5bc657afaa96de811cfe9c6a92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare sizes of two bipartitions, by number of active bits with ties broken by actual bitstrings. <br /></td></tr>
<tr class="separator:a5d7dac5bc657afaa96de811cfe9c6a92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d7aa60b6f49f64b767ee913006b1da6"><td class="memItemLeft" align="right" valign="top"><a id="a1d7aa60b6f49f64b767ee913006b1da6"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#a1d7aa60b6f49f64b767ee913006b1da6">bipartition_flip_to_smaller_set</a> (<a class="el" href="structbipartition__struct.html">bipartition</a> bip)</td></tr>
<tr class="memdesc:a1d7aa60b6f49f64b767ee913006b1da6"><td class="mdescLeft">&#160;</td><td class="mdescRight">invert ones and zeroes in loco when necessary to assure bipartition has more zeroes than ones <br /></td></tr>
<tr class="separator:a1d7aa60b6f49f64b767ee913006b1da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c95530b5714285d8ac0362c5231b2e"><td class="memItemLeft" align="right" valign="top"><a id="a33c95530b5714285d8ac0362c5231b2e"></a>
<a class="el" href="lowlevel_8h.html#a97a80ca1602ebf2303258971a2c938e2">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#a33c95530b5714285d8ac0362c5231b2e">bipartition_is_bit_set</a> (const <a class="el" href="structbipartition__struct.html">bipartition</a> bip, int position)</td></tr>
<tr class="memdesc:a33c95530b5714285d8ac0362c5231b2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if position-th bit is equal to one or not. <br /></td></tr>
<tr class="separator:a33c95530b5714285d8ac0362c5231b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c8c51e60cfaef58946fc3aaa66699f3"><td class="memItemLeft" align="right" valign="top"><a id="a3c8c51e60cfaef58946fc3aaa66699f3"></a>
<a class="el" href="lowlevel_8h.html#a97a80ca1602ebf2303258971a2c938e2">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#a3c8c51e60cfaef58946fc3aaa66699f3">bipartition_contains_bits</a> (const <a class="el" href="structbipartition__struct.html">bipartition</a> b1, const <a class="el" href="structbipartition__struct.html">bipartition</a> b2)</td></tr>
<tr class="memdesc:a3c8c51e60cfaef58946fc3aaa66699f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if first bipartition contains all elements of second bipartition (b2 is a subset of b1) <br /></td></tr>
<tr class="separator:a3c8c51e60cfaef58946fc3aaa66699f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacb095b009713c046c1a7b9e5a0327dc"><td class="memItemLeft" align="right" valign="top"><a id="aacb095b009713c046c1a7b9e5a0327dc"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#aacb095b009713c046c1a7b9e5a0327dc">bipartition_print_to_stdout</a> (const <a class="el" href="structbipartition__struct.html">bipartition</a> b1)</td></tr>
<tr class="memdesc:aacb095b009713c046c1a7b9e5a0327dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print to screen a bit representation of the bipartition (with number of ones at the end) <br /></td></tr>
<tr class="separator:aacb095b009713c046c1a7b9e5a0327dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a806714fe6c29f4c91088507cf78b8905"><td class="memItemLeft" align="right" valign="top"><a id="a806714fe6c29f4c91088507cf78b8905"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#a806714fe6c29f4c91088507cf78b8905">bipartition_replace_bit_in_vector</a> (<a class="el" href="structbipartition__struct.html">bipartition</a> *bvec, int n_b, int to, int from, <a class="el" href="lowlevel_8h.html#a97a80ca1602ebf2303258971a2c938e2">bool</a> reduce)</td></tr>
<tr class="memdesc:a806714fe6c29f4c91088507cf78b8905"><td class="mdescLeft">&#160;</td><td class="mdescRight">replace bit info, copying 'from' one position 'to' another; bool "update" indicates if afterwards size will be reduced <br /></td></tr>
<tr class="separator:a806714fe6c29f4c91088507cf78b8905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f73019b04e2b7283c4b1034d0ab656"><td class="memItemLeft" align="right" valign="top"><a id="a04f73019b04e2b7283c4b1034d0ab656"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#a04f73019b04e2b7283c4b1034d0ab656">bipartition_resize_vector</a> (<a class="el" href="structbipartition__struct.html">bipartition</a> *bvec, int n_b)</td></tr>
<tr class="memdesc:a04f73019b04e2b7283c4b1034d0ab656"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply mask to last element (useful after manipulations) and count number of bits <br /></td></tr>
<tr class="separator:a04f73019b04e2b7283c4b1034d0ab656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6400d669335c7cc5ac2e10907d64a9d"><td class="memItemLeft" align="right" valign="top"><a id="ab6400d669335c7cc5ac2e10907d64a9d"></a>
<a class="el" href="structbipartition__struct.html">tripartition</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#ab6400d669335c7cc5ac2e10907d64a9d">new_tripartition</a> (int nleaves)</td></tr>
<tr class="memdesc:ab6400d669335c7cc5ac2e10907d64a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">tripartition of a node (a vector with 3 bipartitions, that should not be 'flipped' to smaller set, however) <br /></td></tr>
<tr class="separator:ab6400d669335c7cc5ac2e10907d64a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e55ab85d24252191edd3a1768e36816"><td class="memItemLeft" align="right" valign="top"><a id="a7e55ab85d24252191edd3a1768e36816"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#a7e55ab85d24252191edd3a1768e36816">del_tripartition</a> (<a class="el" href="structbipartition__struct.html">tripartition</a> trip)</td></tr>
<tr class="memdesc:a7e55ab85d24252191edd3a1768e36816"><td class="mdescLeft">&#160;</td><td class="mdescRight">free tripartition space (just 3 bipartitions) <br /></td></tr>
<tr class="separator:a7e55ab85d24252191edd3a1768e36816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9a62f4146cce7467b70b179786a4ae"><td class="memItemLeft" align="right" valign="top"><a id="ace9a62f4146cce7467b70b179786a4ae"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#ace9a62f4146cce7467b70b179786a4ae">store_tripartition_from_bipartitions</a> (<a class="el" href="structbipartition__struct.html">tripartition</a> tri, <a class="el" href="structbipartition__struct.html">bipartition</a> b1, <a class="el" href="structbipartition__struct.html">bipartition</a> b2)</td></tr>
<tr class="memdesc:ace9a62f4146cce7467b70b179786a4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">from node, create tripartition from node-&gt;left and node-&gt;right (assuming bipartitions were not 'flipped' yet) <br /></td></tr>
<tr class="separator:ace9a62f4146cce7467b70b179786a4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c938956ea2a3cc95f0be413e9baa072"><td class="memItemLeft" align="right" valign="top"><a id="a3c938956ea2a3cc95f0be413e9baa072"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#a3c938956ea2a3cc95f0be413e9baa072">sort_tripartition</a> (<a class="el" href="structbipartition__struct.html">tripartition</a> tri)</td></tr>
<tr class="memdesc:a3c938956ea2a3cc95f0be413e9baa072"><td class="mdescLeft">&#160;</td><td class="mdescRight">sort order of bipartitions s.t. smallest is first <br /></td></tr>
<tr class="separator:a3c938956ea2a3cc95f0be413e9baa072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eba8eccc761ee9486a4de679448dbc3"><td class="memItemLeft" align="right" valign="top"><a id="a8eba8eccc761ee9486a4de679448dbc3"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#a8eba8eccc761ee9486a4de679448dbc3">align_tripartitions</a> (<a class="el" href="structbipartition__struct.html">tripartition</a> tp1, <a class="el" href="structbipartition__struct.html">tripartition</a> tp2, <a class="el" href="structhungarian__struct.html">hungarian</a> h)</td></tr>
<tr class="memdesc:a8eba8eccc761ee9486a4de679448dbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">match bipartitions between two nodes and return optimal score (min disagreement) <br /></td></tr>
<tr class="separator:a8eba8eccc761ee9486a4de679448dbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a07a32fc365d03a0ecdd94ecd88340f"><td class="memItemLeft" align="right" valign="top"><a id="a8a07a32fc365d03a0ecdd94ecd88340f"></a>
<a class="el" href="lowlevel_8h.html#a97a80ca1602ebf2303258971a2c938e2">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bipartition_8h.html#a8a07a32fc365d03a0ecdd94ecd88340f">tripartition_is_equal</a> (<a class="el" href="structbipartition__struct.html">tripartition</a> tp1, <a class="el" href="structbipartition__struct.html">tripartition</a> tp2)</td></tr>
<tr class="memdesc:a8a07a32fc365d03a0ecdd94ecd88340f"><td class="mdescLeft">&#160;</td><td class="mdescRight">assuming tripartitions are ordered, check if nodes (represented by tripartitions) are the same <br /></td></tr>
<tr class="separator:a8a07a32fc365d03a0ecdd94ecd88340f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Unary/binary operators on arbitrarily-sized bitstrings (strings of zeros and ones) like split bipartitions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a4046e91c94efca27e42476132b89edec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4046e91c94efca27e42476132b89edec">&#9670;&nbsp;</a></span>new_bipartition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structbipartition__struct.html">bipartition</a> new_bipartition </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a new bipartition (bitstring) capable of storing an arbitrary number of bits and initialize it to zero </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of bits of desired bipartition </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bipartition (opaquely a vector of long long ints) </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
